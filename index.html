<!DOCTYPE html>
<meta charset="utf-8">
<html>
    <head>
        <style type="text/css">
            rect.bordered {
            stroke: #E6E6E6;
            stroke-width:2px;
            }
            text.mono {
            font-size: 9pt;
            font-family: Consolas, courier;
            fill: #aaa;
            }
            text.axis-workweek {
            fill: #000;
            }
            text.axis-worktime {
            fill: #000;
            }
            .point {
            fill: #999;
            stroke: #fff;
            }
            .point.scanned {
            fill: orange;
            fill-opacity: 1;
            stroke: brown;
            }
            .point.selected {
            fill: red;
            fill-opacity: 1;
            }
            .node {
            fill: none;
            stroke: #ccc;
            shape-rendering: crispEdges;
            }
            .brush .extent {
            stroke: #fff;
            fill-opacity: .250;
            shape-rendering: crispEdges;
            }
        </style>
        <script src="http://d3js.org/d3.v3.js" type="text/javascript"></script>
        <script src="app.js" type="text/javascript"></script>
    </head>
    <body>
        <div id="chart1"></div>
        <div id="chart2"></div>
        <div id="chart3"></div>
        <script type="text/javascript">
            var width = 500,    height = 480;

            var data = d3.range(1000).map(function() {
                return [Math.random() * width, Math.random() * width];
            });

            var quadtree = d3.geom.quadtree()
                    .extent([[-1, -1], [width + 1, height + 1]])
                    (data);

            var brush1 = d3.svg.brush()
                    .x(d3.scale.identity().domain([0, width/2]))
                    .y(d3.scale.identity().domain([0, height]))
                    .extent([[100, 100], [200, 200]])
                    .on("brush", brushed1);

            var brush2= d3.svg.brush()
                    .x(d3.scale.identity().domain([width/2, width]))
                    .y(d3.scale.identity().domain([0, height]))
                    .extent([[400, 400], [500, 500]])
                    .on("brush", brushed2);


            var svg = d3.select("#chart3").append("svg")
                    .attr("width", width)
                    .attr("height", height);

            svg.append("g")
                    .attr("class", "brush")
                    .call(brush1);

            svg.append("g")
                    .attr("class", "brush")
                    .call(brush2);


            svg.selectAll(".node")
                    .data(nodes(quadtree))
                .enter().append("rect")
                    .attr("class", "node")
                    .attr("x", function(d) { return d.x; })
                    .attr("y", function(d) { return d.y; })
                    .attr("width", function(d) { return d.width; })
                    .attr("height", function(d) { return d.height; });

            var point = svg.selectAll(".point")
                    .data(data)
                    .enter().append("circle")
                    .attr("class", "point")
                    .attr("cx", function(d) { return d[0]; })
                    .attr("cy", function(d) { return d[1]; })
                    .attr("r", 10);


            brushed1();
            brushed2();

            function brushed1() {
                var extent = brush1.extent();
                point.each(function(d) { d.scanned = d.selected = false; });
                search(quadtree, extent[0][0], extent[0][1], extent[1][0], extent[1][1]);
                point.classed("scanned", function(d) { return d.scanned; });
                point.classed("selected", function(d) { return d.selected; });
                brushed2.x=brushed1.x+400;
                brushed2.y=brushed1.y;

            }

            function brushed2() {
                var extent = brush2.extent();
                point.each(function(d) { d.scanned = d.selected = false; });
                search(quadtree, extent[0][0], extent[0][1], extent[1][0], extent[1][1]);
                point.classed("scanned", function(d) { return d.scanned; });
                point.classed("selected", function(d) { return d.selected; });
            }

            // Collapse the quadtree into an array of rectangles.
            function nodes(quadtree) {
                var nodes = [];
                quadtree.visit(function(node, x1, y1, x2, y2) {
                    nodes.push({x: x1, y: y1, width: x2 - x1, height: y2 - y1});
                });
                return nodes;
            }

            // Find the nodes within the specified rectangle.
            function search(quadtree, x0, y0, x3, y3) {
                quadtree.visit(function(node, x1, y1, x2, y2) {
                    var p = node.point;
                    if (p) {
                        p.scanned = true;
                        p.selected = (p[0] >= x0) && (p[0] < x3) && (p[1] >= y0) && (p[1] < y3);
                    }
                    return x1 >= x3 || y1 >= y3 || x2 < x0 || y2 < y0;
                });
            }
        </script>
    </body>
</html>
